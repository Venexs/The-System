
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer


from pathlib import Path

# from tkinter import *
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage, Label, Listbox, Scrollbar, Frame, Y, TOP, BOTH, X
import threading
import json
import csv
import subprocess
import time
import cv2
from PIL import Image, ImageTk
from datetime import datetime, timedelta
import pandas as pd
import sys
import math
import os
from supabase import create_client, Client
import asyncio
from datetime import date
import random
from dotenv import load_dotenv, set_key
from dotenv import load_dotenv, set_key
from infisical_client import ClientSettings, InfisicalClient, GetSecretOptions, AuthenticationOptions, UniversalAuthMethod
import asyncio
from tkinter import messagebox
import pypg

client = InfisicalClient(ClientSettings(
    auth=AuthenticationOptions(
        universal_auth=UniversalAuthMethod(
            client_id="0fa8dbf8-92ee-4889-bd48-1b5dd2d22e87",
            client_secret="a2c9a58bda26c914e333e6c0f7c35e019b30c3afa67b5dc8419a142ee8b2aec8",
        )
    )
))


def get_url():
    # access value
    name = client.getSecret(options=GetSecretOptions(
        environment="dev",
        project_id="a7b312a2-feb6-42bc-92cb-387e37463076",
        secret_name="SUPABASE_URL"
    ))
    return f"{name.secret_value}"
def get_key():
    # access value
    name = client.getSecret(options=GetSecretOptions(
        environment="dev",
        project_id="a7b312a2-feb6-42bc-92cb-387e37463076",
        secret_name="SUPABASE_KEY"
    ))
    return f"{name.secret_value}"

URL = get_url()
KEY = get_key()

supabase: Client = create_client(URL, KEY)

current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.abspath(os.path.join(current_dir, '../../'))
sys.path.insert(0, project_root)

import thesystem.system

OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path(r"assets\frame0")
window = Tk()
window.geometry("488x0")  # Initial collapsed height
window.configure(bg="#FFFFFF")
window.attributes('-alpha', 0.8)
window.overrideredirect(True)
window.wm_attributes("-topmost", True)
thesystem.system.make_window_transparent(window)

# Animate window open
window_width = 488
target_height = 716
subprocess.Popen(['python', 'Files\Mod\default\sfx.py'])
thesystem.system.animate_window_open(window, target_height, window_width, step=40, delay=1)

# Load JSON data once to reduce file I/O
def load_json(file_path):
    with open(file_path, 'r') as file:
        return json.load(file)

status_data = load_json("Files/status.json")
presets_data = load_json("Files/Mod/presets.json")

# Helper Functions
def relative_to_assets(path: str) -> Path:
    return ASSETS_PATH / Path(path)


def start_move(event):
    global lastx, lasty
    lastx, lasty = event.x_root, event.y_root

def move_window(event):
    global lastx, lasty
    x = window.winfo_x() + (event.x_root - lastx)
    y = window.winfo_y() + (event.y_root - lasty)
    window.geometry(f"+{x}+{y}")
    lastx, lasty = event.x_root, event.y_root

# Update and Close Functions
def ex_close(event=None):
    threading.Thread(target=thesystem.system.fade_out, args=(window, 0.8)).start()
    subprocess.Popen(['python', 'Files/Mod/default/sfx_close.py'])
    thesystem.system.animate_window_close(window, 0, window_width, step=20, delay=1)

# Initialize Canvas and Widgets
canvas = Canvas(window, bg="#FFFFFF", height=716, width=488, bd=0, highlightthickness=0, relief="ridge")
canvas.place(x=0, y=0)

# Load images once to avoid redundant processing
images = {
    "background": PhotoImage(file=relative_to_assets("image_1.png")),
    "stats": [
        PhotoImage(file=relative_to_assets(f"image_{i}.png")) for i in range(2, 6)
    ]
}

# Background image and character attributes
canvas.create_image(430.0, 363.0, image=images["background"])
player = thesystem.system.VideoPlayer(canvas, presets_data["Anime"]["Video"], 430.0, 363.0)

image_image_2 = PhotoImage(
    file=relative_to_assets("image_2.png"))
image_2 = canvas.create_image(
    230.0,
    367.0,
    image=image_image_2
)

image_image_3 = PhotoImage(
    file=relative_to_assets("image_3.png"))
image_3 = canvas.create_image(
    150.0,
    117.0,
    image=image_image_3
)

canvas.create_rectangle(
    0.0,
    0.0,
    101.0,
    21.0,
    fill="#0C679B",
    outline="")

canvas.create_rectangle(
    0.0,
    678.0,
    494.0,
    716.0,
    fill="#0C679B",
    outline="")

image_image_19 = PhotoImage(
    file=relative_to_assets("image_19.png"))
image_19 = canvas.create_image(
    -15.0,
    348.0,
    image=image_image_19
)

image_image_20 = PhotoImage(
    file=relative_to_assets("image_20.png"))
image_20 = canvas.create_image(
    462.0,
    351.0,
    image=image_image_20
)

canvas.create_rectangle(
    92.0,
    0.0,
    488.0,
    34.0,
    fill="#0C679B",
    outline="")

button_image_8 = PhotoImage(
    file=relative_to_assets("button_8.png"))
button_8 = Button(
    image=button_image_8,
    borderwidth=0,
    highlightthickness=0,
    command=lambda: ex_close(window),
    relief="flat"
)
button_8.place(
    x=390.0,
    y=55.0,
    width=20.0,
    height=20.0
)

image_image_21 = PhotoImage(
    file=relative_to_assets("image_21.png"))
image_21 = canvas.create_image(
    244.0,
    (19),
    image=image_image_21
)

canvas.tag_bind(image_21, "<ButtonPress-1>", start_move)
canvas.tag_bind(image_21, "<B1-Motion>", move_window)

image_image_22 = PhotoImage(
    file=relative_to_assets("image_22.png"))
image_22 = canvas.create_image(
    295.0,
    680,
    image=image_image_22
)

    


table_name = "status"  # Replace with the actual table name
name_column = "name"  # Replace with the actual name column name
SESSION_FILE = "Files/Data/session.json"

def load_session():
    """Load session data from the session file."""
    if os.path.exists(SESSION_FILE) and os.path.getsize(SESSION_FILE) > 0:
        with open(SESSION_FILE, "r") as f:
            session_data = json.load(f)
            if all(key in session_data for key in ["access_token", "refresh_token", "expires_in"]):
                return session_data

session = load_session()

def get_current_user_id():
    try:
        user_response = supabase.auth.get_user(session["access_token"])  # Synchronous call
        if user_response and user_response.user:
            return user_response.user.id
        else:
            print("User is not authenticated or response is invalid.")  # Add logging for better debugging
            return None
    except Exception as e:
        print(f"Error getting user: {e}")
        return None
    
def get_username_from_id(user_id):
    """Fetch the username of a user given their user_id."""
    try:
        response = supabase.table("status") \
            .select("name") \
            .eq("user_id", user_id) \
            .single() \
            .execute()

        if response.data:
            return response.data["name"]
        else:
            return "Unknown User"
    except Exception as e:
        print(f"Error fetching username: {e}")
        return "Unknown User"
    
def get_all_names(table_name, name_column):
    """Fetches only the 'name' column from the specified table."""
    try:
        response = supabase.table(table_name).select(name_column).execute()
        return [row[name_column] for row in response.data]  # Extract only the 'name' values
    except Exception as e:
        print(f"An error occurred: {e}")
        return []
    
names = get_all_names(table_name, name_column)

def get_pending_invites():
    try:
        current_user_id = get_current_user_id()
        if not current_user_id:
            print("Error", "User is not authenticated.")
            return []

        # Query to fetch pending invites where the current user is the invitee
        response = supabase.table("pvp_invites") \
            .select("*") \
            .eq("invitee_id", current_user_id) \
            .eq("status", "pending") \
            .execute()

        if response.data:
            return response.data  # Return list of pending invites
        else:
            return []
    except Exception as e:
        print("Error", "An error occurred while fetching pending invites.")
        return []
    

def handle_invite_response(invite_id, response):
    """Handles the response to a PVP invite (accept/decline)."""
    try:
        # Update the invite status to either 'accepted' or 'declined'
        update_data = {"status": response}
        invite_response = supabase.table("pvp_invites") \
            .update(update_data) \
            .eq("id", invite_id) \
            .execute()

        if invite_response.data:
            if response == "accepted":
                ex_close(window)
                subprocess.Popen(['python', f'Anime Version/PVP/gui2.py'])
            elif response == "declined":
                messagebox.showinfo("Info", "You have declined the invite.")
        else:
            messagebox.showerror("Error", "Failed to update invite status.")
    except Exception as e:
        print(f"Error handling invite response: {e}")
        messagebox.showerror("Error", "An error occurred while processing your response.")
        
        
def poll_invite_status(invite_id):
    """Polls the status of a specific invite."""
    while True:
        try:
            # Query the invite status
            response = supabase.table("pvp_invites").select("status").eq("id", invite_id).execute()
            if response.data:
                status = response.data[0]["status"]
                if status == "accepted":
                    print("Invite accepted!")
                    # Trigger PVP session
                    break
                elif status == "declined":
                    print("Invite declined.")
                    break
        except Exception as e:
            print(f"Error polling invite status: {e}")
        time.sleep(2)  # Poll every 2 seconds


def start_polling(invite_id):
    polling_thread = threading.Thread(target=poll_invite_status, args=(invite_id,))
    polling_thread.daemon = True  # Ensures the thread exits when the main program ends
    polling_thread.start()
    
    
def get_invite_id():
    try:
        response = supabase.table("pvp_invites") \
            .select("id") \
            .eq("status", "pending") \
            .execute()
        
        if response.data:
            # Assuming you only want the first row
            id = response.data[0]["id"]
            return id
        else:
            print("No pending invite found.")
            return None
    except Exception as e:
        print(f"Error fetching invite: {e}")
        return None

def get_invite_sender():
    try:
        response = supabase.table("pvp_invites") \
            .select("inviter_id") \
            .eq("status", "pending") \
            .execute()
        
        if response.data:
            # Assuming you only want the first row
            id = response.data[0]["inviter_id"]
            return id
        else:
            print("No pending invite found.")
            return None
    except Exception as e:
        print(f"Error fetching invite: {e}")
        return None

def show_pending_invites():
    """Displays a window with the pending invites for the user to accept or decline."""
    pending_invites = get_pending_invites()
    
    if not pending_invites:
        print("No Invites", "You have no pending PVP invites.") 
        
    listbox_container = Frame(window)
    listbox_container.pack(side="top", fill="y", expand=True, padx=(0, 40), pady=150)

    # Configure the Frame to not propagate its size to the Listbox
    listbox_container.pack_propagate(False)
    listbox_container.config(width=350)  # Set the desired width for the Frame
    
    listbox = Listbox(
        listbox_container,  # Place the Listbox inside the Frame
        bg='#010616',
        width=350,  # Set the desired width for the Listbox (will be constrained by the Frame)
        height=10,  # Set an initial height - it will expand with fill="y"
        highlightthickness=0,
        bd=0,
        selectmode="single",  # Disables selection mode
        font=("Montserrat Bold", 12),
        fg="white",  # Set the font color to white (or any color you prefer)
        activestyle="none",
    )
    listbox.pack(side="right", fill="y", expand=True, anchor="center") # Pack the Listbox to the RIGHT

    scrollbar = Scrollbar(listbox_container, command=listbox.yview)
    scrollbar.pack(side="left", fill="y", padx=(0, 5))  # Pack the Scrollbar to the LEFT

    listbox.config(yscrollcommand=scrollbar.set)
    scrollbar.config(command=listbox.yview)
        
    listbox.config(selectbackground="skyblue", selectforeground="black")  # Customize selection color

    for invite in pending_invites:
        inviter_username = get_username_from_id(invite["inviter_id"])  # Assuming you have a method to get the username
        listbox.insert("end", f"Battle invite: {inviter_username}")

    # Initially hide the accept and decline buttons
    accept_button = Button(window, bg="green", text="Engage", command=lambda: on_accept(listbox))
    decline_button = Button(window, bg="red", text="Decline", command=lambda: on_decline(listbox))
    
    accept_button.pack_forget()
    decline_button.pack_forget()

    def on_select(event):
        """Called when an item is selected from the Listbox."""
        selected_index = listbox.curselection()
        if selected_index:
            accept_button.pack(side="left", padx=20, pady=10)
            decline_button.pack(side="right", padx=20, pady=10)
        else:
            # If no item is selected, hide the buttons
            accept_button.pack_forget()
            decline_button.pack_forget()

    def on_accept(listbox):
        """Handle accept invite action."""
        selected_index = listbox.curselection()
        if selected_index:
            invite_id = pending_invites[selected_index[0]]["id"]
            handle_invite_response(invite_id, "accepted")
            invite_id = get_invite_id()  # Replace with the actual invite ID
            sender_id = get_invite_sender
            start_polling(invite_id, )  # Start monitoring the invite
            window.destroy()  # Close the window after handling
        else:
            messagebox.showwarning("Select an Invite", "Please select an invite to respond to.")

    def on_decline(listbox):
        """Handle decline invite action."""
        selected_index = listbox.curselection()
        if selected_index:
            invite_id = pending_invites[selected_index[0]]["id"]
            handle_invite_response(invite_id, "declined")
            window.destroy()  # Close the window after handling
        else:
            messagebox.showwarning("Select an Invite", "Please select an invite to respond to.")

    # Bind the listbox selection event to show/hide the buttons
    listbox.bind("<<ListboxSelect>>", on_select)  # Bind the selection event
show_pending_invites()



window.resizable(False, False)
window.mainloop()
