
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer


from pathlib import Path

# from tkinter import *
# Explicit imports to satisfy Flake8
import tkinter as tk
import subprocess
import threading
import cv2
from PIL import Image, ImageTk
import json
import time
import sys
import os
from supabase import create_client, Client
import asyncio
from tkinter import messagebox
import pypg

current_dir = os.path.dirname(os.path.abspath(__file__))

project_root = os.path.abspath(os.path.join(current_dir, '../../'))

sys.path.insert(0, project_root)

import thesystem.system
import thesystem.dungeon as dungeonbk

subprocess.Popen(['python', 'Files\Mod\default\sfx.py'])

OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path(r"assets\frame0")


URL = "https://smewvswweqnpwzngdtco.supabase.co"
KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNtZXd2c3d3ZXFucHd6bmdkdGNvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQyMDY2NjcsImV4cCI6MjA0OTc4MjY2N30.0SSN0bbwzFMCGC47XUuwqyKfF__Zikm_rJHqXWf78PU"

supabase: Client = create_client(URL, KEY)

def relative_to_assets(path: str) -> Path:
    return ASSETS_PATH / Path(path)


window = tk.Tk()

initial_height = 0
initial_width = 0
target_height = 431
window_width = 712

thesystem.system.make_window_transparent(window)

window.geometry(f"{initial_width}x{initial_height}")
thesystem.system.animate_window_open_middle(window, target_height, window_width, step=20, delay=1)

thesystem.system.center_window(window,window_width,target_height)
window.configure(bg = "#FFFFFF")
window.attributes('-alpha',0.6)
window.overrideredirect(True)
window.wm_attributes("-topmost", True)

def animate_window_close(window, target_height, width, step=2, delay=5):
    current_height = window.winfo_height()
    screen_width = window.winfo_screenwidth()
    screen_height = window.winfo_screenheight()

    window.geometry(f"{width}x{current_height}+{screen_width//2 - width//2}+{screen_height//2 - current_height//2}")

    if current_height > target_height:
        new_height = max(current_height - step, target_height)
    else:
        new_height = current_height
    
    new_y = screen_height // 2 - new_height // 2
    window.geometry(f"{width}x{new_height}+{screen_width//2 - width//2}+{new_y}")

    if new_height > target_height:
        window.after(delay, animate_window_close, window, target_height, width, step, delay)
    else:
        window.quit()

def ex_close(eve):
    subprocess.Popen(['python', 'E:\System\Edited\SystemUpdate3\System_SL-main\Files\Mod\default\sfx_close.py'])
    animate_window_close(window, initial_height, window_width, step=45, delay=1)


canvas = tk.Canvas(
    window,
    bg = "#0678FF",
    height = 432,
    width = 712,
    bd = 0,
    highlightthickness = 0,
    relief = "ridge"
)

canvas.place(x = 0, y = 0)
image_image_1 = tk.PhotoImage(
    file=relative_to_assets("image_1.png"))
image_1 = canvas.create_image(
    356.0,
    216.0,
    image=image_image_1
)

image_image_2 = tk.PhotoImage(
    file=relative_to_assets("image_2.png"))
image_2 = canvas.create_image(
    356.0,
    216.0,
    image=image_image_2
)


button_image_20 = tk.PhotoImage(
    file=relative_to_assets("button_1.png"))
button_20 = tk.Button(
    image=button_image_20,
    borderwidth=0,
    highlightthickness=0,
    command=lambda: ex_close(window),
    relief="flat"
)
button_20.place(
    x=655.0,
    y=35.0,
    width=21.20473861694336,
    height=24.221660614013672
)

transparent_image = Image.new('RGBA', (1, 1), (0, 0, 0, 0))  # Create a 1x1 transparent image
transparent_photo = ImageTk.PhotoImage(transparent_image)

# Add this line below the existing canvas placements
opponent_name_text = canvas.create_text(
    350, 0,  # x, y coordinates
    anchor="n",
    text="PVP INVITES",
    fill="White",  # Text color
    font=("Montserrat Bold", 14),
)

    


table_name = "status"  # Replace with the actual table name
name_column = "name"  # Replace with the actual name column name
SESSION_FILE = "Files/Data/session.json"

def load_session():
    """Load session data from the session file."""
    if os.path.exists(SESSION_FILE) and os.path.getsize(SESSION_FILE) > 0:
        with open(SESSION_FILE, "r") as f:
            session_data = json.load(f)
            if all(key in session_data for key in ["access_token", "refresh_token", "expires_in"]):
                return session_data

session = load_session()

def get_current_user_id():
    try:
        user_response = supabase.auth.get_user(session["access_token"])  # Synchronous call
        if user_response and user_response.user:
            return user_response.user.id
        else:
            print("User is not authenticated or response is invalid.")  # Add logging for better debugging
            return None
    except Exception as e:
        print(f"Error getting user: {e}")
        return None
    
def get_username_from_id(user_id):
    """Fetch the username of a user given their user_id."""
    try:
        response = supabase.table("status") \
            .select("name") \
            .eq("user_id", user_id) \
            .single() \
            .execute()

        if response.data:
            return response.data["name"]
        else:
            return "Unknown User"
    except Exception as e:
        print(f"Error fetching username: {e}")
        return "Unknown User"
    
def get_all_names(table_name, name_column):
    """Fetches only the 'name' column from the specified table."""
    try:
        response = supabase.table(table_name).select(name_column).execute()
        return [row[name_column] for row in response.data]  # Extract only the 'name' values
    except Exception as e:
        print(f"An error occurred: {e}")
        return []
    
names = get_all_names(table_name, name_column)

def get_pending_invites():
    try:
        current_user_id = get_current_user_id()
        if not current_user_id:
            print("Error", "User is not authenticated.")
            return []

        # Query to fetch pending invites where the current user is the invitee
        response = supabase.table("pvp_invites") \
            .select("*") \
            .eq("invitee_id", current_user_id) \
            .eq("status", "pending") \
            .execute()

        if response.data:
            return response.data  # Return list of pending invites
        else:
            return []
    except Exception as e:
        print("Error", "An error occurred while fetching pending invites.")
        return []
    

def handle_invite_response(invite_id, response):
    """Handles the response to a PVP invite (accept/decline)."""
    try:
        # Update the invite status to either 'accepted' or 'declined'
        update_data = {"status": response}
        invite_response = supabase.table("pvp_invites") \
            .update(update_data) \
            .eq("id", invite_id) \
            .execute()

        if invite_response.data:
            if response == "accepted":
                ex_close(window)
                subprocess.Popen(['python', f'Anime Version/PVP/gui2.py'])
            elif response == "declined":
                messagebox.showinfo("Info", "You have declined the invite.")
        else:
            messagebox.showerror("Error", "Failed to update invite status.")
    except Exception as e:
        print(f"Error handling invite response: {e}")
        messagebox.showerror("Error", "An error occurred while processing your response.")
        
        
def poll_invite_status(invite_id):
    """Polls the status of a specific invite."""
    while True:
        try:
            # Query the invite status
            response = supabase.table("pvp_invites").select("status").eq("id", invite_id).execute()
            if response.data:
                status = response.data[0]["status"]
                if status == "accepted":
                    print("Invite accepted!")
                    # Trigger PVP session
                    break
                elif status == "declined":
                    print("Invite declined.")
                    break
        except Exception as e:
            print(f"Error polling invite status: {e}")
        time.sleep(2)  # Poll every 2 seconds


def start_polling(invite_id):
    polling_thread = threading.Thread(target=poll_invite_status, args=(invite_id,))
    polling_thread.daemon = True  # Ensures the thread exits when the main program ends
    polling_thread.start()
    
    
def get_invite_id():
    try:
        response = supabase.table("pvp_invites") \
            .select("id") \
            .eq("status", "pending") \
            .execute()
        
        if response.data:
            # Assuming you only want the first row
            id = response.data[0]["id"]
            return id
        else:
            print("No pending invite found.")
            return None
    except Exception as e:
        print(f"Error fetching invite: {e}")
        return None

def get_invite_sender():
    try:
        response = supabase.table("pvp_invites") \
            .select("inviter_id") \
            .eq("status", "pending") \
            .execute()
        
        if response.data:
            # Assuming you only want the first row
            id = response.data[0]["inviter_id"]
            return id
        else:
            print("No pending invite found.")
            return None
    except Exception as e:
        print(f"Error fetching invite: {e}")
        return None

def show_pending_invites():
    """Displays a window with the pending invites for the user to accept or decline."""
    pending_invites = get_pending_invites()
    
    if not pending_invites:
        print("No Invites", "You have no pending PVP invites.") 
    listbox = tk.Listbox(window, bg='dodgerblue3', width=150, height=150, highlightcolor="deepskyblue2", highlightthickness=2, bd=0, selectmode="single")  # Allow only single selection
    listbox.pack(side="bottom", fill="both", expand=True, padx=20, pady=100)


    scrollbar = tk.Scrollbar(listbox)
    scrollbar.pack(side="right", fill="y")

    listbox.config(yscrollcommand=scrollbar.set)
    scrollbar.config(command=listbox.yview)

    for invite in pending_invites:
        inviter_username = get_username_from_id(invite["inviter_id"])  # Assuming you have a method to get the username
        listbox.insert("end", f"Battle invite: {inviter_username}")

    # Initially hide the accept and decline buttons
    accept_button = tk.Button(window, bg="green", text="Engage", command=lambda: on_accept(listbox))
    decline_button = tk.Button(window, bg="red", text="Decline", command=lambda: on_decline(listbox))
    
    accept_button.pack_forget()
    decline_button.pack_forget()

    def on_select(event):
        """Called when an item is selected from the Listbox."""
        selected_index = listbox.curselection()
        if selected_index:
            accept_button.pack(side="left", padx=20, pady=10)
            decline_button.pack(side="right", padx=20, pady=10)
        else:
            # If no item is selected, hide the buttons
            accept_button.pack_forget()
            decline_button.pack_forget()

    def on_accept(listbox):
        """Handle accept invite action."""
        selected_index = listbox.curselection()
        if selected_index:
            invite_id = pending_invites[selected_index[0]]["id"]
            handle_invite_response(invite_id, "accepted")
            invite_id = get_invite_id()  # Replace with the actual invite ID
            sender_id = get_invite_sender
            start_polling(invite_id, )  # Start monitoring the invite
            window.destroy()  # Close the window after handling
        else:
            messagebox.showwarning("Select an Invite", "Please select an invite to respond to.")

    def on_decline(listbox):
        """Handle decline invite action."""
        selected_index = listbox.curselection()
        if selected_index:
            invite_id = pending_invites[selected_index[0]]["id"]
            handle_invite_response(invite_id, "declined")
            window.destroy()  # Close the window after handling
        else:
            messagebox.showwarning("Select an Invite", "Please select an invite to respond to.")

    # Bind the listbox selection event to show/hide the buttons
    listbox.bind("<<ListboxSelect>>", on_select)  # Bind the selection event
show_pending_invites()


window.resizable(False, False)
window.mainloop()
