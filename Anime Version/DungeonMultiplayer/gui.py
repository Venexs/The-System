# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer

from pathlib import Path

# from tkinter import *
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage, Checkbutton, IntVar, messagebox, Scrollbar, ttk
import ujson
import json
import csv
import subprocess
import random
import time
import threading
#import asyncio  # Import asyncio - REMOVED
from PIL import Image, ImageTk
from datetime import datetime, timedelta
import pandas as pd
import sys
import os
from supabase import create_client, Client
#from supabase.client import create_client as create_supabase_client  # Import async client creator - REMOVED

current_dir = os.path.dirname(os.path.abspath(__file__))

project_root = os.path.abspath(os.path.join(current_dir, '../../'))

sys.path.insert(0, project_root)

import thesystem.system
import thesystem.online
import thesystem.settings as settings

OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path(r"assets\frame0")

with open("Files/Tabs.json",'r') as tab_son:
    tab_son_data=ujson.load(tab_son)

with open("Files/Tabs.json",'w') as fin_tab_son:
    tab_son_data["Settings"]='Open'
    ujson.dump(tab_son_data,fin_tab_son,indent=4)

def relative_to_assets(path: str) -> Path:
    return ASSETS_PATH / Path(path)

window = Tk()

initial_height = 0
target_height = 666
window_width = 475

window.geometry(f"{window_width}x{initial_height}")
thesystem.system.animate_window_open(window, target_height, window_width, step=35, delay=1)

window.configure(bg = "#FFFFFF")
window.attributes('-alpha',0.8)
window.overrideredirect(True)
window.wm_attributes("-topmost", True)

job=thesystem.misc.return_status()["status"][1]["job"]

top_val='dailyquest.py'
all_prev=''
video='Video'
transp_clr='#0C679B'

if job!='None':
    top_val=''
    all_prev='alt_'
    video='Alt Video'
    transp_clr='#652AA3'

thesystem.system.make_window_transparent(window,transp_clr)

top_images = [f"thesystem/{all_prev}top_bar/{top_val}{str(i).zfill(4)}.png" for i in range(1, 501)]
bottom_images = [f"thesystem/{all_prev}bottom_bar/{str(i).zfill(4)}.png" for i in range(1, 501)]

# Preload top and bottom images
top_preloaded_images = thesystem.system.preload_images(top_images, (490, 34))
bottom_preloaded_images = thesystem.system.preload_images(bottom_images, (490, 34))

subprocess.Popen(['python', 'Files\Mod\default\sfx.py'])

with open("Files\Settings.json", 'r') as settings_open:
    setting_data=ujson.load(settings_open)

def start_move(event):
    global lastx, lasty
    lastx = event.x_root
    lasty = event.y_root

def move_window(event):
    global lastx, lasty
    deltax = event.x_root - lastx
    deltay = event.y_root - lasty
    x = window.winfo_x() + deltax
    y = window.winfo_y() + deltay
    window.geometry("+%s+%s" % (x, y))
    lastx = event.x_root
    lasty = event.y_root

def ex_close(win):
    with open("Files/Tabs.json",'r') as tab_son:
        tab_son_data=ujson.load(tab_son)

    with open("Files/Tabs.json",'w') as fin_tab_son:
        tab_son_data["Settings"]='Close'
        ujson.dump(tab_son_data,fin_tab_son,indent=4)
    threading.Thread(target=thesystem.system.fade_out, args=(window, 0.8)).start()
    subprocess.Popen(['python', 'Files\Mod\default\sfx_close.py'])
    thesystem.system.animate_window_close(window, initial_height, window_width, step=20, delay=1)

canvas = Canvas(
    window,
    bg = "#FFFFFF",
    height = 666,
    width = 475,
    bd = 0,
    highlightthickness = 0,
    relief = "ridge"
)
canvas.place(x = 0, y = 0)
image_image_1 = PhotoImage(
    file=relative_to_assets("image_1.png"))
image_1 = canvas.create_image(
    383.0,
    413.0,
    image=image_image_1
)

with open("Files\Mod\presets.json", 'r') as pres_file:
    pres_file_data=ujson.load(pres_file)
    normal_font_col=pres_file_data["Anime"]["Normal Font Color"]
    video_path=pres_file_data["Anime"][video]
player = thesystem.system.VideoPlayer(canvas, video_path, 478.0, 330.0, resize_factor=0.8)

image_image_2 = PhotoImage(
    file=relative_to_assets("image_2.png"))
image_2 = canvas.create_image(
    238.0,
    344.272216796875,
    image=image_image_2
)

image_image_3 = PhotoImage(
    file=relative_to_assets("image_3.png"))
image_3 = canvas.create_image(
    145.0,
    84.0,
    image=image_image_3
)

image_image_4 = PhotoImage(
    file=relative_to_assets("image_4.png"))
image_4 = canvas.create_image(
    240.0,
    365.0,
    image=image_image_4
)


side = PhotoImage(file=relative_to_assets("blue.png"))
if job.upper()!="NONE":
    side = PhotoImage(file=relative_to_assets("purple.png"))
canvas.create_image(-15.0, 348.0, image=side)
canvas.create_image(490.0, 351.0, image=side)

canvas.create_rectangle(
    0.0,
    27.0,
    101.0,
    21.0,
    fill=transp_clr,
    outline="")

canvas.create_rectangle(
    -10.0,
    645.0,
    494.0,
    716.0,
    fill=transp_clr,
    outline="")

canvas.create_rectangle(
    0.0,
    0.0,
    488.0,
    34.0,
    fill=transp_clr,
    outline="")

image_40 = thesystem.system.side_bar("left_bar.png", (81, 640))
canvas.create_image(-5.0, 360.0, image=image_40)

image_50 = thesystem.system.side_bar("right_bar.png", (42, 635))
canvas.create_image(455.0, 340.0, image=image_50)

image_index = 0
bot_image_index = 0

top_image = canvas.create_image(
    240.0,
    27.0,
    image=top_preloaded_images[image_index]
)

canvas.tag_bind(top_image, "<ButtonPress-1>", start_move)
canvas.tag_bind(top_image, "<B1-Motion>", move_window)

bottom_image = canvas.create_image(
    240.0,
    660.0,
    image=bottom_preloaded_images[image_index]
)

step,delay=1,1

def update_images():
    global image_index, bot_image_index

    # Update top image
    image_index = (image_index + 1) % len(top_preloaded_images)
    canvas.itemconfig(top_image, image=top_preloaded_images[image_index])

    # Update bottom image
    bot_image_index = (bot_image_index + 1) % len(bottom_preloaded_images)
    canvas.itemconfig(bottom_image, image=bottom_preloaded_images[bot_image_index])

    # Schedule next update (24 FPS)
    window.after(1000 // 24, update_images)

# Start the animation
update_images()

# =================================================================


SESSION_FILE = "Files/Data/session.json"

def load_session():
    """Load session data from the session file."""
    if os.path.exists(SESSION_FILE) and os.path.getsize(SESSION_FILE) > 0:
        with open(SESSION_FILE, "r") as f:
            session_data = json.load(f)
            if all(key in session_data for key in ["access_token", "refresh_token", "expires_in"]):
                return session_data


session = load_session()

URL = "https://smewvswweqnpwzngdtco.supabase.co"
KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNtZXd2c3d3ZXFucHd6bmdkdGNvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQyMDY2NjcsImV4cCI6MjA0OTc4MjY2N30.0SSN0bbwzFMCGC47XUuwqyKfF__Zikm_rJHqXWf78PU"

supabase: Client = create_client(URL, KEY) # type: ignore


# Add after supabase = create_client(...)

# Dungeon Configuration
DUNGEON_TYPES = ["Ancient Temple", "Frozen Cavern", "Lava Forge", "Sky Citadel"]
EXERCISE_TYPES = ["Push-ups", "Squats", "Plank", "Burpees", "Jumping Jacks"]
DIFFICULTY_MODES = ["Easy", "Normal", "Hard", "Nightmare"]

class DungeonEngine:
    def __init__(self, canvas, status_data):
        self.canvas = canvas
        self.status = status_data
        self.current_dungeon = None
        self.difficulty = self.calculate_difficulty()
        self.user_id = thesystem.online.get_current_user_id(supabase_client=supabase, session=session)  # Get user ID

        # GUI Elements
        self.dungeon_text = Text(window, wrap="word", bg="#1A1A1A", fg="white",
                               font=("Consolas", 10), borderwidth=0)
        self.dungeon_text.place(x=50, y=120, width=375, height=250)

        self.create_button = Button(window, text="Create Dungeon", command=self.create_dungeon,
                                  bg="#404040", fg="white", relief="flat")
        self.create_button.place(x=50, y=540, width=120, height=30)

        # Treeview for available dungeons
        self.tree = ttk.Treeview(window, columns=('Name', 'ID'), show='headings', style="Darkstyle.Treeview")
        self.tree.heading('Name', text='Name', anchor='w')
        self.tree.heading('ID', text='ID', anchor='w')

        # Set column widths
        self.tree.column('Name', width=250, anchor='w')
        self.tree.column('ID', width=120, anchor='w')

        self.tree.place(x=50, y=380, width=375, height=100)

        # Style
        self.style = ttk.Style(window)
        self.style.theme_use('default')  # Use a built-in theme as a base

        self.style.configure("Darkstyle.Treeview",
                             background="#404040",
                             foreground="white",
                             fieldbackground="#404040",
                             borderwidth=0)

        self.style.configure("Darkstyle.Treeview.Heading",
                             background="#404040",
                             foreground="white",
                             borderwidth=0,
                             font=('Arial', 10, 'bold'))

        self.style.map("Darkstyle.Treeview",
                       background=[("selected", "#0C679B")],
                       foreground=[("selected", "white")])

        self.tree.tag_configure('oddrow', background="#404040")
        self.tree.tag_configure('evenrow', background="#303030")


        # Scrollbar
        self.scrollbar = Scrollbar(window, orient="vertical", command=self.tree.yview)
        self.scrollbar.place(x=425, y=380, height=100)
        self.tree.configure(yscrollcommand=self.scrollbar.set)


        self.join_button = Button(window, text="Join Dungeon", command=self.join_dungeon_from_tree,
                                bg="#404040", fg="white", relief="flat")
        self.join_button.place(x=200, y=540, width=120, height=30)

        self.update_dungeon_list()

    def calculate_difficulty(self):
        base = (self.status['str'] + self.status['agi'] +
               self.status['vit']) / 3
        return min(int(base // 5), 3)  # 0-3 index for DIFFICULTY_MODES

    def generate_dungeon(self):
        dungeon = {
            "Name": f"{random.choice(DUNGEON_TYPES)} of {random.choice(['Pain', 'Sweat', 'Glory'])}",
            "type": random.choice(DUNGEON_TYPES),
            "difficulty": DIFFICULTY_MODES[self.difficulty],
            "rooms": [],
            "current_room": 0,
            "players": [],
            "status": "waiting",  # Initial status
            "created_at": datetime.now().isoformat(),
            "creator_id": self.user_id
        }

        # Generate random rooms based on difficulty
        num_rooms = random.randint(3 + self.difficulty, 6 + self.difficulty * 2)
        for _ in range(num_rooms):
            room = {
                "exercise": random.choice(EXERCISE_TYPES),
                "target": random.randint(5 + self.difficulty * 5, 15 + self.difficulty * 10),
                "time_limit": random.randint(30 - self.difficulty * 5, 60 - self.difficulty * 10),
                "completed": False
            }
            dungeon["rooms"].append(room)

        return dungeon

    def create_dungeon(self):
        try:
            self.current_dungeon = self.generate_dungeon()
            result = supabase.table('dungeons').insert({
                "Name": self.current_dungeon['Name'],
                "data": self.current_dungeon
            }).execute()

            self.current_dungeon['id'] = result.data[0]['id']  # Store the dungeon ID
            self.update_display("Dungeon created! Waiting for players...")
            #  Removed self.setup_realtime_monitoring() call
            self.update_dungeon_list() # Refresh list after creating
        except Exception as e:
            print(f"error creating dungeon {e}")
            messagebox.showerror("Error", f"Error creating dungeon: {e}")


    def update_display(self, text):
        self.dungeon_text.config(state="normal")
        self.dungeon_text.delete(1.0, "end")
        self.dungeon_text.insert("end", text)
        self.dungeon_text.config(state="disabled")



    # Removed setup_realtime_monitoring and related methods
    # Removed on_dungeon_update, _realtime_monitor

    def run_dungeon(self, dungeon_data):
        # Full dungeon execution logic
        self.update_display("Dungeon starting!\n\n")
        for i, room in enumerate(dungeon_data['rooms']):
            result = self.run_room(room, i + 1)
            if not result:
                self.update_display("Dungeon failed! Returning to town...")
                return
        self.update_display("Dungeon completed successfully!")
        self.reward_player()

    def run_room(self, room, number):
        # Implement actual exercise tracking here
        exercise = f"Room {number}: {room['exercise']} x{room['target']} ({room['time_limit']}s)"
        self.update_display(f"\n{exercise}\nPress Start when ready...")
        return random.random() > 0.2  # 80% success chance for demo

    def reward_player(self):
        # Update player status
        new_strength = self.status['str'] + random.randint(1, 3)
        supabase.table('status').update({
            'str': new_strength
        }).eq('user_id', self.user_id).execute()


    def update_dungeon_list(self):
        # Populate available dungeons in the Treeview
        try:
            dungeons = supabase.table('dungeons').select('Name,Rank,created_at, data, id').eq(
                'data->>status', 'waiting').execute().data

            # Clear the treeview
            for item in self.tree.get_children():
                self.tree.delete(item)

            # Add dungeons to the treeview
            for i, dungeon in enumerate(dungeons):
                dungeon_name = dungeon['Name']
                dungeon_id = dungeon['id']
                if i % 2 == 0:
                    self.tree.insert("", "end", values=(dungeon_name, dungeon_id), tags=('evenrow',))
                else:
                    self.tree.insert("", "end", values=(dungeon_name, dungeon_id), tags=('oddrow',))


        except Exception as e:
            print(f"Error fetching dungeons: {str(e)}")
            messagebox.showerror("Error", f"Error fetching dungeons: {str(e)}")

    def join_dungeon_from_tree(self):
        # Get selected dungeon ID from the Treeview
        selection = self.tree.selection()
        if selection:
            selected_item = selection[0]
            dungeon_id = self.tree.item(selected_item, 'values')[1]  # Get the 'ID' column value
            self.join_dungeon(dungeon_id)
        else:
            messagebox.showinfo("Info", "Please select a dungeon to join.")


    def join_dungeon(self, dungeon_id):
        # Implement dungeon joining logic (same as before, but using the dungeon_id from the list)
        try:
            # Fetch the dungeon data from Supabase
            dungeon_response = supabase.table('dungeons').select('*').eq('id', dungeon_id).execute()

            if dungeon_response.data:
                dungeon = dungeon_response.data[0]['data']  # Access the dungeon data
                dungeon_name = dungeon_response.data[0]['Name']

                # Check if the dungeon is already active or completed
                if dungeon['status'] == 'active':
                    messagebox.showinfo("Info", "This dungeon is already active.")
                    return
                elif dungeon['status'] == 'completed':
                    messagebox.showinfo("Info", "This dungeon is already completed.")
                    return
                if self.user_id in dungeon['players']:
                    messagebox.showinfo("Info", "You have already joined this dungeon.")
                    return

                # Add the current player to the dungeon's player list
                dungeon['players'].append(self.user_id)

                # Update the dungeon data in Supabase with the new player list
                update_response = supabase.table('dungeons').update({
                    'data': dungeon
                }).eq('id', dungeon_id).execute()

                if update_response:
                    self.update_display(f"Joined dungeon {dungeon_name}! Waiting for the creator to start")

                    # If this is the dungeon creator, immediately start the dungeon

                    if dungeon['creator_id'] == self.user_id:
                        dungeon['status'] = 'active'
                        supabase.table('dungeons').update({
                            'data': dungeon
                        }).eq('id', dungeon_id).execute()
                        self.run_dungeon(dungeon) # Runs dungeon if creator joins.
                    else:
                        self.monitor_dungeon_join(dungeon_id)

                    self.current_dungeon = dungeon  # Keep track of the current dungeon


                else:
                    messagebox.showerror("Error", "Failed to join the dungeon.")
            else:
                messagebox.showinfo("Info", "Dungeon not found.")
        except Exception as e:
            print(f"Error joining dungeon: {str(e)}")
            messagebox.showerror("Error", f"Error joining dungeon: {str(e)}")

    def monitor_dungeon_join(self, dungeon_id):
        # Simplified monitoring (no asyncio, just polling)
        def _monitor():
            while True:
                data = supabase.table('dungeons').select('*').eq(
                    'id', dungeon_id
                ).execute().data[0]

                if data['data']['status'] == 'active':
                    self.run_dungeon(data['data'])  # Correctly pass data
                    break
                time.sleep(2)

        threading.Thread(target=_monitor, daemon=True).start()

# Get player status data
try:
    status_data = supabase.table('status').select('*').eq(
        'user_id', thesystem.online.get_current_user_id(supabase_client=supabase, session=session)
    ).execute().data[0]
    dungeon_engine = DungeonEngine(canvas, status_data)
except Exception as e:
    messagebox.showerror("Error", f"Failed to load player status: {str(e)}")
    window.destroy()

window.resizable(False, False)
window.mainloop()