
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer
import sys
#Safely convert dungeon_id to an integer
try:
    if len(sys.argv) > 1:
        dungeon_id = int(sys.argv[1])
        print(f"Dungeon Runs Multiplayer is starting for dungeon ID: {dungeon_id}")
    else:
        dungeon_id = None
        print("Anime Version/Dungeon Runs Multiplayer started without a dungeon ID.  This will likely cause errors.")

except ValueError:
    print("Error: Dungeon ID must be an integer.")
    dungeon_id = None #Set None so everything else is skipped too!

from pathlib import Path
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage, WORD
import ujson
import csv
import subprocess
import cv2
import math
from PIL import Image, ImageTk
import threading
import sys
import os
import google.generativeai as genai
import os
from supabase import create_client
import random
import time

current_dir = os.path.dirname(os.path.abspath(__file__))

project_root = os.path.abspath(os.path.join(current_dir, '../../'))

sys.path.insert(0, project_root)

import thesystem.system
import thesystem.inventory

OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path(r"assets\frame0")

YOUR_API_KEY = "AIzaSyBcV8U32iIXkd8Kyd9EZE2bbIbsahgOFI8"

with open("Files/Tabs.json",'r') as tab_son:
    tab_son_data=ujson.load(tab_son)

with open("Files/Tabs.json",'w') as fin_tab_son:
    tab_son_data["Inventory"]='Open'
    ujson.dump(tab_son_data,fin_tab_son,indent=4)

def relative_to_assets(path: str) -> Path:
    return ASSETS_PATH / Path(path)

window = Tk()

initial_height = 0
target_height = 592
window_width = 855

window.geometry(f"{window_width}x{initial_height}")
job=thesystem.misc.return_status()["status"][1]["job"]

top_val='dailyquest.py'
all_prev=''
video='Video'
transp_clr='#0C679B'

if job!='None':
    top_val=''
    all_prev='alt_'
    video='Alt Video'
    transp_clr='#652AA3'

thesystem.system.make_window_transparent(window,transp_clr)

top_images = [f"thesystem/{all_prev}top_bar/{top_val}{str(i).zfill(4)}.png" for i in range(1, 501)]
bottom_images = [f"thesystem/{all_prev}bottom_bar/{str(i).zfill(4)}.png" for i in range(1, 501)]

thesystem.system.animate_window_open(window, target_height, window_width, step=30, delay=1)

window.configure(bg = "#FFFFFF")
window.attributes('-alpha',0.8)
window.overrideredirect(True)
window.wm_attributes("-topmost", True)

# Preload top and bottom images
top_preloaded_images = thesystem.system.preload_images(top_images, (970, 40))
bottom_preloaded_images = thesystem.system.preload_images(bottom_images, (970, 40))

subprocess.Popen(['python', 'Files\Mod\default\sfx.py'])

def start_move(event):
    global lastx, lasty
    lastx = event.x_root
    lasty = event.y_root

def move_window(event):
    global lastx, lasty
    deltax = event.x_root - lastx
    deltay = event.y_root - lasty
    x = window.winfo_x() + deltax
    y = window.winfo_y() + deltay
    window.geometry("+%s+%s" % (x, y))
    lastx = event.x_root
    lasty = event.y_root

URL = "https://smewvswweqnpwzngdtco.supabase.co"
KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNtZXd2c3d3ZXFucHd6bmdkdGNvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQyMDY2NjcsImV4cCI6MjA0OTc4MjY2N30.0SSN0bbwzFMCGC47XUuwqyKfF__Zikm_rJHqXWf78PU"

supabase = create_client(URL, KEY)

# dungeon_id

def ex_close(win):
    with open("Files/Tabs.json",'r') as tab_son:
        tab_son_data=ujson.load(tab_son)

    with open("Files/Tabs.json",'w') as fin_tab_son:
        tab_son_data["Inventory"]='Close'
        ujson.dump(tab_son_data,fin_tab_son,indent=4)
    threading.Thread(target=thesystem.system.fade_out, args=(window, 0.8)).start()
    subprocess.Popen(['python', 'Files\Mod\default\sfx_close.py'])
    thesystem.system.animate_window_close(window, initial_height, window_width, step=50, delay=1)

canvas = Canvas(
    window,
    bg = "#FFFFFF",
    height = 592,
    width = 855,
    bd = 0,
    highlightthickness = 0,
    relief = "ridge"
)

canvas.place(x = 0, y = 0)
image_image_1 = PhotoImage(
    file=relative_to_assets("image_1.png"))
image_1 = canvas.create_image(
    479.0,
    364.0,
    image=image_image_1
)

with open("Files\Mod\presets.json", 'r') as pres_file:
    pres_file_data=ujson.load(pres_file)
    video_path=pres_file_data["Anime"][video]
player = thesystem.system.VideoPlayer(canvas, video_path, 479.0, 364.0)



image_image_4 = PhotoImage(
    file=relative_to_assets("image_4.png"))
image_4 = canvas.create_image(
    433.0,
    117.0,
    image=image_image_4
)


side = PhotoImage(file=relative_to_assets("blue.png"))
if job.upper()!="NONE":
    side = PhotoImage(file=relative_to_assets("purple.png"))
canvas.create_image(-10.0, 283.0, image=side)
canvas.create_image(851.0, 308.0, image=side)

canvas.create_rectangle(
    0.0,
    0.0,
    101.0,
    21.0,
    fill=transp_clr,
    outline="")

canvas.create_rectangle(
    0.0,
    520.0,
    1000.0,
    716.0,
    fill=transp_clr,
    outline="")

canvas.create_rectangle(
    0.0,
    0.0,
    1000.0,
    34.0,
    fill=transp_clr,
    outline="")

image_40 = thesystem.system.side_bar("left_bar.png", (101, 520))
canvas.create_image(-13.0, 280.0, image=image_40)

image_50 = thesystem.system.side_bar("right_bar.png", (80, 500))
canvas.create_image(851.0, 280.0, image=image_50)

image_index = 0
bot_image_index = 0

top_image = canvas.create_image(
    472.0,
    20.0,
    image=top_preloaded_images[image_index]
)

canvas.tag_bind(top_image, "<ButtonPress-1>", start_move)
canvas.tag_bind(top_image, "<B1-Motion>", move_window)

bottom_image = canvas.create_image(
    427.0,
    530.0,
    image=bottom_preloaded_images[bot_image_index]
)

step,delay=1,1

def update_images():
    global image_index, bot_image_index

    # Update top image
    image_index = (image_index + 1) % len(top_preloaded_images)
    canvas.itemconfig(top_image, image=top_preloaded_images[image_index])

    # Update bottom image
    bot_image_index = (bot_image_index + 1) % len(bottom_preloaded_images)
    canvas.itemconfig(bottom_image, image=bottom_preloaded_images[bot_image_index])

    # Schedule next update (24 FPS)
    window.after(1000 // 24, update_images)

# Start the animation
update_images()

# =========================================================================================================


button_image_26 = PhotoImage(
    file=relative_to_assets("button_26.png"))
button_26 = Button(
    image=button_image_26,
    borderwidth=0,
    highlightthickness=0,
    command=lambda: ex_close(window),
    relief="flat"
)
button_26.place(
    x=806.0,
    y=64.0,
    width=20.0,
    height=20.0
)


import tkinter as tk

VIGNETTE_COLOR = "#000000"  # Black, can be adjusted.  Keep it DARK.

def generate_procedural_map(width=30, height=30, room_size_range=(2, 5), max_rooms=15):
    """Generates a simple procedural dungeon map as a 2D list."""
    dungeon_map = [['#' for _ in range(width)] for _ in range(height)]
    rooms = []

    def create_room(x, y, room_width, room_height):
        for i in range(y, y + room_height):
            for j in range(x, x + room_width):
                dungeon_map[i][j] = '.'

    def rooms_intersect(room1, room2):
        x1, y1, w1, h1 = room1
        x2, y2, w2, h2 = room2
        return not (x1 + w1 < x2 or x2 + w2 < x1 or y1 + h1 < y2 or y2 + h2 < y1)

    for _ in range(max_rooms):
        room_width = random.randint(room_size_range[0], room_size_range[1])
        room_height = random.randint(room_size_range[0], room_size_range[1])
        x = random.randint(1, width - room_width - 1)
        y = random.randint(1, height - room_height - 1)
        new_room = (x, y, room_width, room_height)

        intersects = False
        for existing_room in rooms:
            if rooms_intersect(new_room, existing_room):
                intersects = True
                break

        if not intersects:
            create_room(x, y, room_width, room_height)
            rooms.append(new_room)

    for i in range(len(rooms) - 1):
        x1, y1, w1, h1 = rooms[i]
        x2, y2, w2, h2 = rooms[i + 1]
        center1 = (x1 + w1 // 2, y1 + h1 // 2)
        center2 = (x2 + w2 // 2, y2 + h2 // 2)

        x = center1[0]
        y = center1[1]

        while x != center2[0]:
            dungeon_map[y][x] = '.'
            x += 1 if center2[0] > center1[0] else -1

        while y != center2[1]:
            dungeon_map[y][x] = '.'
            y += 1 if center2[1] > center1[1] else -1

    return dungeon_map

def display_dungeon(dungeon_map, canvas, cell_size=10, offset_x=50, offset_y=150):
    """Displays the dungeon map on a given Tkinter canvas, scaled down and moved."""
    height = len(dungeon_map)
    width = len(dungeon_map[0])

    canvas.delete("dungeon") #Clear the canvas with tag

    for y in range(height):
        for x in range(width):
            if dungeon_map[y][x] == '.':
                color = "black"  # Floor
            else:
                color = "#1c506c"  # Wall

            x1 = x * cell_size + offset_x
            y1 = y * cell_size + offset_y
            x2 = (x + 1) * cell_size + offset_x
            y2 = (y + 1) * cell_size + offset_y

            canvas.create_rectangle(x1, y1, x2, y2,
                                    fill=color, outline="", tag="dungeon")  # Add "dungeon" tag

def update_vignette(canvas, vignette_radius, canvas_width, canvas_height):
    """Updates the vignette effect on the canvas with an inverted appearance."""
    canvas.delete("vignette")  # Clear previous vignette

    center_x = canvas_width / 2
    center_y = canvas_height / 2
    num_steps = 50

    for i in range(num_steps):
        radius = vignette_radius
        alpha = (1 - (i / num_steps)) * 0.9
        hex_alpha = hex(int(alpha * 255))[2:].zfill(2)
        fill_color = "#000000"

        canvas.create_oval(center_x - radius, center_y - radius,
                            center_x + radius, center_y + radius,
                            fill=fill_color, outline="", tag="vignette")

def update_flashlight_effect(canvas, cell_size, offset_x, offset_y, dungeon_map, flashlight_radius, center=None):

    # Compute dungeon bounding box in pixels:
    dungeon_height = len(dungeon_map)
    dungeon_width = len(dungeon_map[0]) if dungeon_height else 0
    x1 = offset_x
    y1 = offset_y
    x2 = offset_x + cell_size * dungeon_width
    y2 = offset_y + cell_size * dungeon_height

    # Determine flashlight center:
    if center is None:
        cx = (x1 + x2) / 2
        cy = (y1 + y2) / 2
    else:
        cx, cy = center

    # Delete previous flashlight overlay items:
    canvas.delete("flashlight")

    # Draw four rectangles to cover areas outside the flashlight circle:
    # Top rectangle (from dungeon top to top of circle)
    canvas.create_rectangle(x1, y1, x2, cy - flashlight_radius,
                            fill="grey", outline="", tag="flashlight")
    # Bottom rectangle (from bottom of circle to dungeon bottom)
    canvas.create_rectangle(x1, cy + flashlight_radius, x2, y2,
                            fill="grey", outline="", tag="flashlight")
    # Left rectangle (covering left side between the top and bottom parts of the circle)
    canvas.create_rectangle(x1, cy - flashlight_radius, cx - flashlight_radius, cy + flashlight_radius,
                            fill="grey", outline="", tag="flashlight")
    # Right rectangle (covering right side)
    canvas.create_rectangle(cx + flashlight_radius, cy - flashlight_radius, x2, cy + flashlight_radius,
                            fill="grey", outline="", tag="flashlight")

dungeon = generate_procedural_map()  # You can adjust the width and height in this call
display_dungeon(dungeon, canvas, cell_size=10) # Adjust cell_size as needed


progress = 25

update_flashlight_effect(canvas, cell_size=10, offset_x=50, offset_y=150, dungeon_map=dungeon, flashlight_radius=progress)



def create_dungeon_details_box(canvas, x, y, width, height, text, tag):
    """Creates a filled rectangle with text inside on the given canvas."""

    # Background rectangle
    canvas.create_rectangle(x, y, x + width, y + height,
                            fill="#1c506c", outline="#000000", tag=tag)  # Dark blue/grey background

    # Text inside the rectangle
    text_id = canvas.create_text(x + width/2, y + height/2,
                                text=text,
                                font=("Montserrat Bold", 10),  # Adjust font size
                                fill="#FFFFFF",
                                justify="center", tag=tag)  # White text, center-aligned

    #  Get the actual bounding box of the text
    bbox = canvas.bbox(text_id)

    #  If the text is too big, shrink it to be within the box with some margin
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]
    margin = 10
    scale_x = (width - 2 * margin) / text_width if text_width > (width - 2 * margin) else 1
    scale_y = (height - 2 * margin) / text_height if text_height > (height - 2 * margin) else 1
    scale = min(scale_x, scale_y)

    #  If the text needs to be scaled, scale it down
    if scale < 1:
        canvas.scale(text_id, x + width/2, y + height/2, scale, scale)
        #The .scale method is deprecated, use transform_from_center instead
        #canvas.transform_from_center(text_id, x + width/2, y + height/2, scale, scale)
        

def create_group_goals_box(canvas, x, y, width, height, goals, tag):
    # Background rectangle
    canvas.create_rectangle(x, y, x + width, y + height,
                            fill="#1c506c", outline="#000000", tag=tag)

    # Format goals into a single string
    goals_text = "\n".join([f"- {goal}" for goal in goals])

    # Text inside the rectangle
    canvas.create_text(x + width / 2, y + height / 2 - 25,
                    text="DUNGEON GOAL:",
                    font=("Montserrat Bold", 10),
                    fill="#FFFFFF",
                    justify="center", tag=tag)  # Changed to left justification
    
    # Text inside the rectangle
    canvas.create_text(x + width / 2, y + height / 2,
                    text=goals_text,
                    font=("Montserrat Bold", 10),
                    fill="#FFFFFF",
                    justify="left", tag=tag)  # Changed to left justification


#Dungeon Text Information
dungeon_details = f"DUNGEON:\nName: Example\nType: Dungeon"
create_dungeon_details_box(canvas, 500, 150, 300, 150, dungeon_details, "text_box")  # Adjust coordinates and sizes

#Group Goals and information text
group_goals = ["Read 75 pages", "Do a group total of 1000 pushups"]
create_group_goals_box(canvas, 500, 325, 300, 100, group_goals, "group_box")  # Coordinates and size of your Group Goals box



window.resizable(False, False)
window.mainloop()